---
title: "Analysis of Single-cell (Spatial) Transcriptomics From Mouse Embryos"
author: "Ziang Zhang"
date: "2024-11-15"
output: workflowr::wflow_html
---

## Data

This single cell RNA data is available [here](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE166692), as studied in [Srivatsan et al, 2021](https://www.science.org/doi/10.1126/science.abb9536).

The dataset considers $108725$ cells and $39198$ genes (after QC), measured with spatial locations in the mouse embryo. 

```{r eval=T, message=FALSE, warning=FALSE}
library(Seurat)
library(Matrix)
library(data.table)
library(flashier)
library(ggplot2)
library(patchwork)
library(cowplot)
library(RColorBrewer)
library(Biobase)
library(ggpubr)
library(gridExtra)
library(fastTopics)
source('../code/plot_loadings_on_umap.R')
source("../code/Customized_Plots.R")
seurat_object <- readRDS("../data/mouse_embryo/processed_seurat/seurat_object.rds")
Y <- t(seurat_object$RNA$data)
```

The data contains the UMAP information that we can directly use for visualization, and compare with the "anatomical annotation" and the "cluster label" in [Srivatsan et al, 2021](https://www.science.org/doi/10.1126/science.abb9536).

```{r eval=T, fig.width=12, fig.height=5, message=FALSE, results='hide', warning=FALSE}
umap_original_embeddings <- cbind(seurat_object$umap1, seurat_object$umap2)
p1 <- DimPlotSagnik(umap_original_embeddings, group.by = seurat_object$anatomical_annotation, pt.size = 1) +
  theme(plot.title = element_text(hjust = 0.5)) +
  ggtitle("UMAP by Anatomical Annotation")

p2 <- DimPlotSagnik(umap_original_embeddings, group.by = seurat_object$final_cluster_label, pt.size = 1) +
  theme(plot.title = element_text(hjust = 0.5)) +
  ggtitle("UMAP by Cluster Label")

# Combine plots side-by-side
combined_plot <- p1 + p2 + plot_layout(ncol = 2)
combined_plot
```


## Trying EBMF

Let's try to implement the EBMF algorithm with the `flashier` package, with different constraints and prior distributions.

Considering the large computational cost, we will first try to run the EBMF algorithm without backfitting.

```{r eval=FALSE,message=FALSE, warning=FALSE}
cols_to_keep <- colSums(Y != 0, na.rm = TRUE) > 0
Y <- Y[, cols_to_keep]
n  <- nrow(Y)
x  <- rpois(1e7, 1/n)
s1 <- sd(log(x + 1))
a <- 1
size_factors <- rowSums(Y)
size_factors <- size_factors / mean(size_factors)
shifted_log_counts <- log1p(Y / (a * size_factors))
```

### Non-Negative EBMF

For the first EBMF problem, we consider non-negative EBMF with `point_exponential` priors:

```{r eval=FALSE}
flashier_fit_nn <- flash(shifted_log_counts,
                      ebnm_fn = ebnm_point_exponential,
                      var_type = 2,
                      greedy_Kmax = 25,
                      S = s1,
                      backfit = F)
plot(flashier_fit_nn, 
     plot_type = "structure",
     pm_which = "loadings", 
     pm_groups = seurat_object$final_cluster_label,
     bins = 20, gap = 70)
```

```{r, eval=T, message=FALSE, results='hide',fig.keep='all', echo=FALSE}
flashier_fit_nn <- readRDS("../output/mouse_embryo/flashier_fit_nn.rds")
plot(flashier_fit_nn, 
     plot_type = "structure",
     pm_which = "loadings", 
     pm_groups = seurat_object$final_cluster_label,
     bins = 20, gap = 70)
```


### Semi Non-Negative EBMF

```{r eval=FALSE}
ebnm_fn_list <- list()
ebnm_fn_list[[1]] <- flash_ebnm(
  prior_family = "point_exponential"
)
ebnm_fn_list[[2]] <- flash_ebnm(
  prior_family = "point_normal",
  mode = "estimate"
)
flashier_fit_semi <- flash(shifted_log_counts,
                      ebnm_fn = ebnm_fn_list,
                      var_type = 2,
                      greedy_Kmax = 25,
                      S = s1,
                      backfit = F)
plot(flashier_fit_semi, 
     plot_type = "structure",
     pm_which = "loadings", 
     pm_groups = seurat_object$final_cluster_label,
     bins = 20, gap = 70)
```

```{r eval=T, message=FALSE, results='hide',fig.keep='all', echo=FALSE}
flashier_fit_semi <- readRDS("../output/mouse_embryo/flashier_fit_semi.rds")
ebnm_fn_list <- list()
ebnm_fn_list[[1]] <- flash_ebnm(
  prior_family = "point_exponential"
)
ebnm_fn_list[[2]] <- flash_ebnm(
  prior_family = "point_normal",
  mode = "estimate"
)
plot(flashier_fit_semi, 
     plot_type = "structure",
     pm_which = "loadings", 
     pm_groups = seurat_object$final_cluster_label,
     bins = 20, gap = 70)
```


### GB Semi Non-Negative EBMF

```{r eval=FALSE}
ebnm_fn_list <- list()
ebnm_fn_list[[1]] <- flash_ebnm(
  prior_family = "generalized_binary"
)
ebnm_fn_list[[2]] <- flash_ebnm(
  prior_family = "point_laplace",
  mode = "estimate"
)
flashier_fit_gbcd <- flash(shifted_log_counts,
                      ebnm_fn = ebnm_fn_list,
                      var_type = 2,
                      greedy_Kmax = 25,
                      S = s1,
                      backfit = F)
plot(flashier_fit_gbcd, 
     plot_type = "structure",
     pm_which = "loadings", 
     pm_groups = seurat_object$final_cluster_label,
     bins = 20, gap = 70)
```

```{r eval=T, message=FALSE, results='hide',fig.keep='all', echo=FALSE}
flashier_fit_gbcd <- readRDS("../output/mouse_embryo/flashier_fit_gbcd.rds")
ebnm_fn_list <- list()
ebnm_fn_list[[1]] <- flash_ebnm(
  prior_family = "generalized_binary"
)
ebnm_fn_list[[2]] <- flash_ebnm(
  prior_family = "point_laplace",
  mode = "estimate"
)
plot(flashier_fit_gbcd, 
     plot_type = "structure",
     pm_which = "loadings", 
     pm_groups = seurat_object$final_cluster_label,
     bins = 20, gap = 70)
```

### GBCD

```{r eval=FALSE}
res.gbcd <- fit_gbcd(Y = Y, Kmax = 25, maxiter1 = 100,
                     maxiter2 = 50, maxiter3 = 50, 
                     prior = flash_ebnm(prior_family = "generalized_binary",
                                        scale = 0.04))
saveRDS(res.gbcd, "../output/mouse_embryo/res.gbcd.rds")
```

```{r include=FALSE}
# res.gbcd <- readRDS("../output/mouse_embryo/res.gbcd.rds")
# anno <- data.frame(sample = seurat_object$sample, subtype = seurat_object$final_cluster_label)
# rownames(anno) <- rownames(res.gbcd$L)
# anno_colors <- list(sample = seurat_object$sample, subtype = seurat_object$final_cluster_label)
# cols <- colorRampPalette(c("gray96", "red"))(50)
# brks <- seq(0, 1, 0.02)
```



## Trying Topic Models

Then, let's try fitting a topic model to this dataset using `FastTopics`.

```{r eval = FALSE}
fasttopics_fit <- fit_topic_model(Y, k = 25)
```

```{r include=FALSE}
fasttopics_fit <- readRDS("../output/mouse_embryo/fasttopics_fit.rds")
```

```{r eval=T, message=FALSE, results='hide',fig.keep='all', echo=FALSE}
structure_plot(fasttopics_fit, grouping = seurat_object$final_cluster_label, gap = 70)
```


## Summarize Structures from Loadings

There are some interesting structures of the loading based on the result of EBMF and FastTopics, that add new insights to the original UMAP visualization.

### Non-negative EBMF

First, based on the non-negative EBMF result, there are some factors that are shared across multiple cell types. For example:

- The factors $k10$ and $k3$ are shared across multiple types of neurons and glial cells.

- The factor $k5$ is shared across Chondrocytes and Connective Tissue Progenitors.

- The factor $k2$ is shared across Erythroid Progenitors and Hepatocytes.

- The factor $k9$ is unique to Endothelial Cells.

- The factor $k7$ is unique to White Blood Cells.

Let's take a look at how the UMAF plot looks if we color each cell based on its composition of these factors.

```{r eval=T, message=FALSE, results='hide',fig.keep='all', echo=FALSE}
library(patchwork) 

# Collect all plots in a list
plots <- list()
colnames(umap_original_embeddings) <- c("UMAP_1", "UMAP_2")

for (f in c(2, 3, 5, 7, 9, 10)) {
  loading <- flashier_fit_nn$L_pm[, f]
  p <- plot_loadings_on_umap(umap = umap_original_embeddings, loading = loading, factor_num = f, size = 1)
  plots[[length(plots) + 1]] <- ggplotGrob(p)
}

combined_plot <- wrap_plots(plots, ncol = 3, nrow = 2)

# Display the combined plot
print(combined_plot)
```
 

### Semi-negative EBMF

The loadings from the semi-negative EBMF are more diverse, where each cell is composed of a larger number of factors.
However, there are still both "unique" and "shared" factors across different cell types. For examples:

- Factor $k4$ is shared across multiple types of neurons and glial cells.

- Factor $k2$ is shared across Erythroid Progenitors and Hepatocytes.

- Factor $k3$ is mostly unique to Myocytes and Cardiac Muscle. 

- Factor $k12$ is unique to Chondrocytes.

```{r eval=T, message=FALSE, results='hide',fig.keep='all', echo=FALSE}
# Collect all plots in a list
plots <- list()
colnames(umap_original_embeddings) <- c("UMAP_1", "UMAP_2")

for (f in c(2,3,4,12)) {
  loading <- flashier_fit_semi$L_pm[, f]
  p <- plot_loadings_on_umap(umap = umap_original_embeddings, loading = loading, factor_num = f, size = 1)
  plots[[length(plots) + 1]] <- ggplotGrob(p)
}

# Combine the plots in a 2x3 grid
combined_plot <- wrap_plots(plots, ncol = 2, nrow = 2)

# Display the combined plot
print(combined_plot)
```

### FastTopics

The result from FastTopics looks quite similar to the semi-negative EBMF, where each cell is composed of a larger number of factors. For examples:

- Factors $k13$ and $k10$ are shared across Erythroid Progenitors and Hepatocytes.

- Factor $k3$ is unique to Hepatocytes.

- Factor $k8$ is unique to White Blood Cells.


```{r eval=T, message=FALSE, results='hide', fig.keep='all', echo=FALSE}
# Collect all plots in a list
plots <- list()
colnames(umap_original_embeddings) <- c("UMAP_1", "UMAP_2")

for (f in c(13, 10, 3, 8)) {
  loading <- fasttopics_fit$L[, f]
  p <- plot_loadings_on_umap(umap = umap_original_embeddings, loading = loading, factor_num = f, size = 1)
  plots[[length(plots) + 1]] <- ggplotGrob(p)
}

# Combine the plots in a 2x3 grid
combined_plot <- wrap_plots(plots, ncol = 2, nrow = 2)

# Display the combined plot
print(combined_plot)
```




## Compare these methods

- The non-negative EBMF provides a kind of "cleaner composition" of each cell, where each cell is mostly composed of one base line factor and another factor that is " kind of specific" to the cell type. This in a way demonstrates the advantage of the part-based representation (plus sparsity).

- The semi non-negative EBMF provides a more "diverse" composition of each cell, where each cell is composed of a base line factor and multiple other factors that may appear in different cell types. The compensate of the "diversity" is the computation of this problem tends to be a bit more stable than the non-negative EBMF.

- The FastTopics also provides a kind of diverse composition of each cell, where each cell is composed of multiple factors. This might be due to there is no sparsity constraint in the FastTopics model.

- Overall, they all found some quite interesting structures (shared or unique) that are not obvious from the original UMAP visualization. 




